import {
  getFirestore,
  collection,
  doc,
  writeBatch,
  getDoc,
} from "firebase/firestore";

const coursesData = [
  {
    id: "programming-basics",
    title: "Основы программирования",
    description:
      "Изучите фундаментальные концепции программирования на примере JavaScript",
    category: "Программирование",
    thumbnail: "programming-basics.jpg",
    totalLessons: 15, // Общее количество уроков для расчета прогресса
    modules: [
      {
        id: "module-1",
        title: "Введение в программирование",
        description: "Изучите что такое программирование и основные концепции",
        lessons: [
          {
            id: "lesson-1-1",
            title: "Что такое программирование?",
            description: "Знакомство с миром программирования",
            stages: [
              {
                order: 0,
                type: "theory",
                title: "Что такое программирование",
                content:
                  "Программирование — это процесс создания компьютерных программ с помощью языков программирования. По сути, это способ общения с компьютером, чтобы он выполнял нужные нам задачи.",
              },
              {
                order: 1,
                type: "practice_mcq",
                title: "Проверка понимания",
                content:
                  "Что из перечисленного НЕ является языком программирования?",
                options: ["JavaScript", "Python", "HTML", "C++"],
                correctAnswer: 2,
                explanation:
                  "HTML — это язык разметки, который используется для создания структуры веб-страниц, а не язык программирования.",
              },
              {
                order: 2,
                type: "theory",
                title: "Зачем нужно программирование",
                content:
                  "Программирование позволяет создавать программы и приложения, которые решают конкретные задачи. Благодаря программированию возможно создание веб-сайтов, мобильных приложений, игр и многого другого.",
              },
              {
                order: 3,
                type: "practice_fill_blank",
                title: "Заполните пропуск",
                content:
                  "С помощью программирования можно создавать _______, игры и приложения.",
                correctAnswer: "веб-сайты",
                explanation:
                  "Программирование используется для создания различных программных продуктов, включая веб-сайты.",
              },
              {
                order: 4,
                type: "theory",
                title: "Как работает программа",
                content:
                  "Программы — это набор инструкций, которые компьютер выполняет последовательно. Компьютер не понимает человеческий язык, поэтому инструкции записываются на языках программирования, которые затем преобразуются в машинный код.",
              },
              {
                order: 5,
                type: "practice_code_input",
                title: "Ваш первый код",
                content:
                  "Напишите команду для вывода текста 'Привет, мир!' на JavaScript",
                correctAnswer: "console.log('Привет, мир!');",
                explanation:
                  "console.log() — это функция, которая выводит текст или значение переменной в консоль.",
              },
              {
                order: 6,
                type: "theory",
                title: "Подведем итоги",
                content:
                  "В этом уроке мы познакомились с программированием, узнали что это такое и зачем оно нужно. В следующих уроках мы углубимся в детали и начнем писать больше кода.",
              },
            ],
          },
          {
            id: "lesson-1-2",
            title: "Переменные и типы данных",
            description:
              "Изучите, что такое переменные и какие бывают типы данных",
            stages: [
              {
                order: 0,
                type: "theory",
                title: "Что такое переменные?",
                content:
                  "Переменные - это именованные контейнеры для хранения данных в программе. Представьте их как коробки с этикетками, куда можно что-то положить.",
              },
              {
                order: 1,
                type: "theory",
                title: "Объявление переменных (let, const, var)",
                content:
                  "В JavaScript переменные объявляются с помощью ключевых слов: `let` (для изменяемых переменных), `const` (для констант, которые нельзя переназначить) и `var` (старый способ, лучше использовать `let` или `const`).\nПример: `let age = 25; const PI = 3.14;`",
              },
              {
                order: 2,
                type: "practice_mcq",
                title: "Проверка: Объявление",
                content:
                  "Какое ключевое слово используется для объявления переменной, значение которой НЕЛЬЗЯ изменить позже?",
                options: ["var", "let", "const", "set"],
                correctAnswer: 2,
                explanation:
                  "`const` используется для объявления констант, значения которых не могут быть переназначены после инициализации.",
              },
              {
                order: 3,
                type: "theory",
                title: "Типы данных: Числа и Строки",
                content:
                  "Основные типы данных: `Number` (числа, например, `10`, `3.14`) и `String` (строки текста, например, `'Привет'` или `\"Мир\"`). Строки заключаются в одинарные или двойные кавычки.",
              },
              {
                order: 4,
                type: "practice_fill_blank",
                title: "Проверка: Типы данных",
                content:
                  "Тип данных для текста, как 'Hello', называется ______.",
                correctAnswer: "String",
                explanation:
                  "Строки (String) используются для представления текстовых данных.",
              },
              {
                order: 5,
                type: "theory",
                title: "Типы данных: Булевы значения",
                content:
                  "Булев тип (`Boolean`) имеет только два значения: `true` (истина) и `false` (ложь). Они часто используются в условиях.",
              },
              {
                order: 6,
                type: "practice_code_input",
                title: "Практика: Объявление",
                content:
                  "Объявите константу `MAX_USERS` и присвойте ей числовое значение `100`.",
                correctAnswer: "const MAX_USERS = 100;",
                explanation:
                  "Используем `const` для константы, `MAX_USERS` как имя и присваиваем `100`.",
              },
              {
                order: 7,
                type: "theory",
                title: "Итог",
                content:
                  "Мы изучили переменные (`let`, `const`), числа (`Number`), строки (`String`) и булевы значения (`Boolean`). Это основа для работы с данными в JavaScript!",
              },
            ],
          },
        ],
      },
      {
        id: "module-2",
        title: "Основные конструкции",
        description:
          "Изучите основные конструкции программирования: условия и циклы",
        lessons: [
          {
            id: "lesson-2-1",
            title: "Условные операторы",
            description:
              "Изучите как принимать решения в коде с помощью условий",
            stages: [
              {
                order: 0,
                type: "theory",
                title: "Зачем нужны условия? Оператор if",
                content:
                  "Часто в программах нужно выполнять разные действия в зависимости от ситуации. Например, показать сообщение об ошибке, если пользователь ввел неверный пароль. Для этого используются условные операторы. \nСамый главный - это `if`. Он проверяет условие в скобках `()`. Если условие истинно (`true`), выполняется код внутри фигурных скобок `{}`.\n`if (условие) { // код, если условие true }`",
              },
              {
                order: 1,
                type: "practice_mcq",
                title: "Проверка: if",
                content:
                  "Какой код будет выполнен? `let age = 20; if (age > 18) { console.log('Совершеннолетний'); }`",
                options: [
                  "Никакой",
                  "console.log('Совершеннолетний')",
                  "Будет ошибка",
                ],
                correctAnswer: 1,
                explanation:
                  "Условие `age > 18` (20 > 18) истинно, поэтому код внутри `{}` выполнится.",
              },
              {
                order: 2,
                type: "theory",
                title: "А если условие ложно? Оператор else",
                content:
                  "Что если условие в `if` оказалось ложным (`false`)? Чтобы выполнить другой код в этом случае, используется `else`. Он идет сразу после `if`.\n`if (условие) { // код, если true } else { // код, если false }`",
              },
              {
                order: 3,
                type: "practice_code_input",
                title: "Практика: if-else",
                content:
                  "Напишите код: если переменная `isLoggedIn` равна `true`, вывести 'Вход выполнен', иначе - 'Войдите в систему'. Считайте, что `isLoggedIn` уже объявлена.",
                correctAnswer:
                  "if (isLoggedIn) {console.log('Вход выполнен');} else {console.log('Войдите в систему');}",
                explanation:
                  "Используем `if (isLoggedIn)` для проверки `true`, и `else` для случая `false`.",
              },
              {
                order: 4,
                type: "theory",
                title: "Несколько условий: else if",
                content:
                  "Иногда нужно проверить несколько условий подряд. Для этого после `if` можно добавить `else if`. \n`if (условие1) { // код 1 } else if (условие2) { // код 2 } else { // код, если все условия false }`\nПроверка идет по порядку. Как только найдется истинное условие, выполнится его код, и остальные `else if` и `else` проигнорируются.",
              },
              {
                order: 5,
                type: "practice_fill_blank",
                title: "Практика: else if",
                content:
                  "Дополните код для проверки оценки: `let grade = 4; if (grade === 5) { console.log('Отлично'); } ____ (grade === 4) { console.log('Хорошо'); } else { console.log('Учиться!'); }`",
                correctAnswer: "else if",
                explanation:
                  "`else if` используется для проверки второго условия, если первое (`grade === 5`) ложно.",
              },
              {
                order: 6,
                type: "practice_mcq",
                title: "Проверка: Порядок выполнения",
                content:
                  "Что выведется в консоль? `let x = 10; if (x > 5) { console.log('A'); } else if (x > 0) { console.log('B'); } else { console.log('C'); }`",
                options: ["A", "B", "C", "A и B"],
                correctAnswer: 0,
                explanation:
                  "Первое же условие `x > 5` (10 > 5) истинно. Выполняется его блок (`console.log('A')`), а остальные `else if` и `else` игнорируются.",
              },
              {
                order: 7,
                type: "theory",
                title: "Итог по условиям",
                content:
                  "Мы рассмотрели `if`, `else` и `else if`. Эти конструкции позволяют вашей программе принимать решения и выполнять разный код в зависимости от ситуации. Это фундаментальная часть программирования!",
              },
            ],
          },
          {
            id: "lesson-2-2",
            title: "Циклы",
            description: "Повторение действий с помощью циклов",
            stages: [
              {
                order: 0,
                type: "theory",
                title: "Зачем нужны циклы? Цикл for",
                content:
                  "Представьте, что вам нужно вывести числа от 1 до 5. Писать `console.log(1)`, `console.log(2)` и т.д. неудобно. Циклы позволяют повторять один и тот же код много раз.\nСамый частый цикл - `for`. Его синтаксис: `for (инициализация; условие; шаг) { // тело цикла }`\n- **Инициализация:** Выполняется один раз перед началом цикла (обычно объявление счетчика, `let i = 0`).\n- **Условие:** Проверяется перед каждой итерацией. Если `true` - цикл продолжается, если `false` - заканчивается.\n- **Шаг:** Выполняется после каждой итерации (обычно изменение счетчика, `i++`).\n- **Тело цикла:** Код, который повторяется.",
              },
              {
                order: 1,
                type: "practice_fill_blank",
                title: "Практика: Части for",
                content:
                  "В цикле `for (let i = 0; i < 10; i++)`, какая часть отвечает за проверку продолжения цикла? `let i = 0; ______; i++`",
                correctAnswer: "i < 10",
                explanation:
                  "Условие `i < 10` проверяется перед каждой итерацией.",
              },
              {
                order: 2,
                type: "theory",
                title: "Пример: Вывод чисел",
                content:
                  "Выведем числа от 0 до 4:\n`for (let i = 0; i < 5; i++) { console.log(i); }`\n1. `i` становится 0.\n2. Условие `0 < 5` true. Выполняем `console.log(0)`. Шаг `i++` (i=1).\n3. Условие `1 < 5` true. Выполняем `console.log(1)`. Шаг `i++` (i=2).\n4. ...\n5. Условие `4 < 5` true. Выполняем `console.log(4)`. Шаг `i++` (i=5).\n6. Условие `5 < 5` false. Цикл завершается.",
              },
              {
                order: 3,
                type: "practice_code_input",
                title: "Практика: Цикл for",
                content:
                  "Напишите цикл `for`, который выводит в консоль числа от 1 до 3 (включительно).",
                correctAnswer:
                  "for (let i = 1; i <= 3; i++) {\n  console.log(i);\n}",
                explanation: "Начинаем с `i = 1`, условие `i <= 3`, шаг `i++`.",
              },
              {
                order: 4,
                type: "theory",
                title: "Цикл while",
                content:
                  "Еще один вид цикла - `while`. Он проще: `while (условие) { // тело цикла }`\nТело цикла выполняется, пока условие истинно (`true`). Важно не забыть внутри тела изменять переменную, влияющую на условие, иначе цикл станет бесконечным!\nПример вывода чисел от 0 до 4:\n`let i = 0; while (i < 5) { console.log(i); i++; }`",
              },
              {
                order: 5,
                type: "practice_mcq",
                title: "Проверка: while",
                content:
                  "Что выведет этот код? `let count = 3; while (count > 0) { console.log(count); count--; }`",
                options: ["3, 2, 1", "3, 2, 1, 0", "3, 2", "Бесконечный цикл"],
                correctAnswer: 0,
                explanation:
                  "Цикл работает пока `count > 0`. Выводятся 3, 2, 1. Когда `count` становится 0, условие `0 > 0` ложно, цикл останавливается.",
              },
              {
                order: 6,
                type: "theory",
                title: "Итог по циклам",
                content:
                  "Циклы `for` и `while` позволяют эффективно повторять код. `for` удобен, когда известно количество итераций, `while` - когда повторение зависит от выполнения условия. Это мощные инструменты для решения многих задач!",
              },
            ],
          },
        ],
      },
      {
        id: "module-3",
        title: "Структуры данных",
        description: "Хранение и организация данных: Массивы и Объекты",
        lessons: [
          {
            id: "lesson-3-1",
            title: "Массивы",
            description: "Работа с упорядоченными коллекциями данных",
            stages: [
              {
                order: 0,
                type: "theory",
                title: "Что такое массив?",
                content:
                  "Массив - это упорядоченная коллекция элементов. Представьте список покупок или очередь. В JavaScript массивы создаются с помощью квадратных скобок `[]`, элементы перечисляются через запятую.\nПример: `let fruits = ['Яблоко', 'Банан', 'Апельсин'];`",
              },
              {
                order: 1,
                type: "theory",
                title: "Доступ к элементам. Индексы",
                content:
                  "Элементы в массиве нумеруются с **нуля**. Этот номер называется **индекс**. Чтобы получить элемент, указываем имя массива и индекс в квадратных скобках.\n`fruits[0]` вернет 'Яблоко'\n`fruits[1]` вернет 'Банан'",
              },
              {
                order: 2,
                type: "practice_mcq",
                title: "Проверка: Индексы",
                content:
                  "Какой элемент будет получен? `let colors = ['red', 'green', 'blue']; console.log(colors[2]);`",
                options: ["red", "green", "blue", "Ошибка"],
                correctAnswer: 2,
                explanation:
                  "Индекс `2` соответствует третьему элементу массива, так как нумерация начинается с 0.",
              },
              {
                order: 3,
                type: "theory",
                title: "Длина массива",
                content:
                  "Узнать количество элементов в массиве можно с помощью свойства `length`.\n`colors.length` вернет `3`.",
              },
              {
                order: 4,
                type: "practice_code_input",
                title: "Практика: Длина массива",
                content:
                  "Дан массив `let numbers = [10, 20, 30, 40];`. Напишите код для вывода его длины в консоль.",
                correctAnswer: "console.log(numbers.length);",
                explanation:
                  "Свойство `length` массива `numbers` вернет количество его элементов (4).",
              },
              {
                order: 5,
                type: "theory",
                title: "Изменение элементов и добавление",
                content:
                  "Элементы массива можно изменять по индексу: `fruits[1] = 'Киви';` (теперь массив `['Яблоко', 'Киви', 'Апельсин']`).\nДобавить элемент в конец массива можно методом `push()`: `fruits.push('Груша');`",
              },
              {
                order: 6,
                type: "practice_fill_blank",
                title: "Практика: Добавление",
                content:
                  "Какой метод используется для добавления элемента в конец массива? `myArray.____('новый элемент');`",
                correctAnswer: "push",
                explanation:
                  "Метод `push()` добавляет один или несколько элементов в конец массива.",
              },
              {
                order: 7,
                type: "theory",
                title: "Итог по массивам",
                content:
                  "Массивы позволяют хранить упорядоченные коллекции данных и легко получать к ним доступ по индексу. Это очень полезная структура данных!",
              },
            ],
          },
          {
            id: "lesson-3-2",
            title: "Объекты",
            description: "Хранение данных в формате ключ-значение",
            stages: [
              {
                order: 0,
                type: "theory",
                title: "Что такое объект?",
                content:
                  "Объект - это неупорядоченная коллекция пар **ключ-значение**. Ключ (или свойство) - это строка, а значение - любые данные (число, строка, другой объект, массив и т.д.). Объекты создаются с помощью фигурных скобок `{}`.\nПример: `let user = { name: 'Иван', age: 30, isAdmin: true };`",
              },
              {
                order: 1,
                type: "theory",
                title: "Доступ к свойствам",
                content:
                  "Получить значение свойства можно двумя способами:\n1. Через точку: `user.name` вернет 'Иван'.\n2. Через квадратные скобки: `user['age']` вернет 30. Этот способ нужен, если ключ содержит пробелы или является переменной.",
              },
              {
                order: 2,
                type: "practice_mcq",
                title: "Проверка: Доступ через точку",
                content:
                  "Как получить значение свойства `city` из объекта `let address = { street: 'Ленина', city: 'Москва' };`?",
                options: [
                  "address[city]",
                  "address.city",
                  "address('city')",
                  "city.address",
                ],
                correctAnswer: 1,
                explanation:
                  "Доступ через точку `object.property` является стандартным способом.",
              },
              {
                order: 3,
                type: "theory",
                title: "Изменение и добавление свойств",
                content:
                  "Значения свойств можно изменять: `user.age = 31;`.\nНовые свойства можно добавлять так же: `user.city = 'Санкт-Петербург';`",
              },
              {
                order: 4,
                type: "practice_code_input",
                title: "Практика: Добавление свойства",
                content:
                  "Дан объект `let car = { brand: 'Toyota' };`. Добавьте ему свойство `color` со значением `'red'`.",
                correctAnswer: "car.color = 'red';",
                explanation:
                  "Просто присваиваем значение новому свойству `color` объекта `car`.",
              },
              {
                order: 5,
                type: "theory",
                title: "Итог по объектам",
                content:
                  "Объекты идеально подходят для представления сущностей с набором характеристик (пользователь, товар, заказ). Они позволяют удобно структурировать данные с помощью именованных ключей.",
              },
            ],
          },
        ],
      },
      {
        id: "module-4",
        title: "Функции",
        description: "Создание переиспользуемых блоков кода",
        lessons: [
          {
            id: "lesson-4-1",
            title: "Основы функций",
            description: "Объявление, вызов, параметры и возврат значений",
            stages: [
              {
                order: 0,
                type: "theory",
                title: "Что такое функция?",
                content:
                  "Функция - это блок кода, который можно вызывать (запускать) много раз. Это помогает избежать повторения кода и делает программу более организованной. \nФункции объявляются с помощью ключевого слова `function`, затем идет имя функции, скобки `()` для параметров и фигурные скобки `{}` для тела функции.\n`function greet() { console.log('Привет!'); }`",
              },
              {
                order: 1,
                type: "theory",
                title: "Вызов функции",
                content:
                  "Чтобы выполнить код внутри функции, ее нужно **вызвать**. Для этого пишем имя функции и добавляем круглые скобки `()`.\n`greet();` вызовет функцию выше и выведет 'Привет!'.",
              },
              {
                order: 2,
                type: "practice_code_input",
                title: "Практика: Вызов функции",
                content:
                  "Дана функция `function sayBye() { console.log('Пока!'); }`. Напишите код для ее вызова.",
                correctAnswer: "sayBye();",
                explanation:
                  "Вызов функции осуществляется указанием ее имени и круглых скобок.",
              },
              {
                order: 3,
                type: "theory",
                title: "Параметры функции",
                content:
                  "Функции могут принимать **параметры** (входные данные). Они перечисляются в круглых скобках при объявлении. При вызове функции мы передаем **аргументы** - конкретные значения для этих параметров.\n`function greetUser(name) { console.log('Привет, ' + name + '!'); }`\n`greetUser('Анна');` выведет 'Привет, Анна!'. Здесь `name` - параметр, 'Анна' - аргумент.",
              },
              {
                order: 4,
                type: "practice_mcq",
                title: "Проверка: Параметры",
                content:
                  "Что такое `userName` в коде `function showMessage(userName) { /*...*/ }`?",
                options: ["Аргумент", "Переменная", "Параметр", "Тип данных"],
                correctAnswer: 2,
                explanation:
                  "`userName` - это параметр, который функция ожидает получить при вызове.",
              },
              {
                order: 5,
                type: "theory",
                title: "Возврат значения: return",
                content:
                  "Функции могут не только выполнять действия, но и **возвращать** результат своей работы с помощью ключевого слова `return`. После `return` выполнение функции прекращается.\n`function add(a, b) { return a + b; }`\n`let sum = add(5, 3); // sum будет равно 8`",
              },
              {
                order: 6,
                type: "practice_code_input",
                title: "Практика: return",
                content:
                  "Напишите функцию `multiply` которая принимает два параметра и возвращает их произведение.",
                correctAnswer: "function multiply(a, b) {\n  return a * b;\n}",
                explanation:
                  "Функция `multiply` принимает `a` и `b`, и использует `return`, чтобы вернуть результат `a * b`.",
              },
              {
                order: 7,
                type: "theory",
                title: "Итог по функциям",
                content:
                  "Функции - это строительные блоки программы. Они позволяют делить код на логические части, избегать повторений и делать код более читаемым и поддерживаемым. Мы рассмотрели объявление, вызов, параметры и возврат значений.",
              },
            ],
          },
        ],
      },
    ],
  },
  {
    id: "graphic-design",
    title: "Графический дизайн: Старт в Figma", // Уточнил название
    description: "Основы дизайна интерфейсов и работа с редактором Figma", // Уточнил описание
    category: "Дизайн",
    thumbnail: "course2.png",
    totalLessons: 17, // Обновлено ~ до 17 этапов
    modules: [
      {
        id: "figma-module-1",
        title: "Введение в Figma",
        description: "Знакомство с интерфейсом и основными возможностями",
        lessons: [
          {
            id: "figma-l1-1",
            title: "Знакомство с Figma",
            description: "Что такое Figma и обзор ее интерфейса",
            stages: [
              // Старые этапы 0-3 остаются без изменений
              {
                order: 0, // Общий порядок 0
                type: "theory",
                title: "Что такое Figma?",
                content:
                  "Figma — это популярный онлайн-редактор для дизайна интерфейсов (сайтов, приложений) и векторной графики. Он удобен для совместной работы и доступен прямо в браузере.",
              },
              {
                order: 1, // Общий порядок 1
                type: "practice_mcq",
                title: "Проверка: Назначение Figma",
                content: "Для чего в первую очередь НЕ предназначена Figma?",
                options: [
                  "Дизайн веб-сайтов",
                  "Создание иконок",
                  "Видеомонтаж",
                  "Прототипирование интерфейсов",
                ],
                correctAnswer: 2,
                explanation:
                  "Figma — это инструмент для дизайна и прототипирования, а не для редактирования видео.",
              },
              {
                order: 2, // Общий порядок 2
                type: "theory",
                title: "Обзор интерфейса",
                content:
                  "Основные части интерфейса Figma:\n- **Холст (Canvas):** Центральная область, где вы создаете дизайн.\n- **Панель слоев (Layers Panel):** Слева, показывает все объекты на холсте.\n- **Панель инструментов (Toolbar):** Сверху, содержит инструменты (Фигуры, Текст, Frame и т.д.).\n- **Панель свойств (Properties Panel):** Справа, позволяет настраивать выбранный объект (цвет, размер, шрифт и т.д.).",
              },
              {
                order: 3, // Общий порядок 3
                type: "practice_fill_blank",
                title: "Проверка: Интерфейс",
                content:
                  "Панель ________ показывает список всех объектов на холсте.",
                correctAnswer: "Слоев",
                explanation:
                  "Панель слоев (Layers Panel) слева отображает иерархию ваших объектов.",
              },
            ],
          },
        ],
      },
      {
        id: "figma-module-2",
        title: "Основы работы",
        description:
          "Создание фигур, работа с текстом, цветом, выравниванием и эффектами", // Добавил эффекты в описание
        lessons: [
          {
            id: "figma-l2-1",
            title: "Фигуры и Фреймы",
            description: "Создание базовых элементов и настройка их вида", // Уточнил описание
            stages: [
              {
                order: 0, // Общий порядок 4
                type: "theory",
                title: "Создание фигур и Frame",
                content:
                  "Основные инструменты:\n- **Rectangle (R), Ellipse (O), Line (L):** Создают прямоугольники, овалы и линии.\n- **Frame (F):** Создает контейнер (артборд) для вашего дизайна, например, экран телефона или веб-страницу. Всегда начинайте работу внутри фрейма!",
              },
              {
                order: 1, // Общий порядок 5
                type: "practice_mcq",
                title: "Проверка: Frame",
                content:
                  "Какой инструмент используется для создания 'холста' для конкретного экрана (например, iPhone 14)?",
                options: ["Rectangle", "Frame", "Slice", "Line"],
                correctAnswer: 1,
                explanation:
                  "Инструмент Frame (F) используется для создания артбордов заданного или произвольного размера.",
              },
              {
                order: 2, // Общий порядок 6
                type: "theory",
                title: "Цвет заливки (Fill)",
                content:
                  "На панели свойств справа в секции **Fill** можно настроить заливку фигуры:\n- **Solid:** Сплошной цвет (выбирается пипеткой или из палитры).\n- **Linear/Radial Gradient:** Линейный или радиальный градиент (переход между цветами).\n- **Image:** Заливка изображением.",
              },
              {
                // Новый этап
                order: 3, // Общий порядок 7
                type: "practice_mcq",
                title: "Проверка: Заливка",
                content:
                  "Как называется тип заливки, представляющий плавный переход между двумя или более цветами?",
                options: ["Solid", "Stroke", "Gradient", "Image"],
                correctAnswer: 2,
                explanation:
                  "Градиент (Gradient) создает плавный переход цветов.",
              },
              {
                order: 4, // Общий порядок 8 (бывший 6, переименован)
                type: "theory",
                title: "Обводка (Stroke)",
                content:
                  "В секции **Stroke** настраивается линия по контуру объекта:\n- **Цвет и толщина:** Задаются так же, как у заливки.\n- **Положение:** Inside (внутри), Outside (снаружи), Center (по центру контура).\n- **Стиль:** Сплошная, пунктирная (Dashed).",
              },
              {
                // Новый этап
                order: 5, // Общий порядок 9
                type: "theory",
                title: "Эффекты (Effects)",
                content:
                  "Секция **Effects** позволяет добавлять тени, размытие и другие эффекты. Самый частый - **Drop Shadow** (падающая тень). Нажмите '+' в секции Effects и выберите Drop Shadow, затем настройте смещение (X, Y), размытие (Blur) и цвет тени.",
              },
            ],
          },
          {
            id: "figma-l2-2",
            title: "Текст, Группировка и Выравнивание", // Добавил Группировку
            description:
              "Добавление текста, объединение и расположение объектов", // Уточнил
            stages: [
              {
                order: 0, // Общий порядок 10
                type: "theory",
                title: "Работа с текстом (T)",
                content:
                  "Инструмент **Text (T)** позволяет добавлять текстовые блоки. На панели свойств можно изменить шрифт, размер, начертание (bold, regular), выравнивание текста и межстрочный интервал.",
              },
              {
                // Новый этап
                order: 1, // Общий порядок 11
                type: "theory",
                title: "Группировка объектов",
                content:
                  "Чтобы объединить несколько объектов в группу (для удобства перемещения или применения общих стилей), выделите их и нажмите `Ctrl+G` (или `Cmd+G` на Mac). Разгруппировать - `Ctrl+Shift+G` (`Cmd+Shift+G`).",
              },
              {
                order: 2, // Общий порядок 12 (бывший 8)
                type: "theory",
                title: "Выравнивание и Распределение", // Уточнил название
                content:
                  "Чтобы аккуратно расположить элементы:\n- Выделите несколько объектов и используйте кнопки **выравнивания** на панели свойств (по левому/правому краю, центру, верху/низу).\n- Кнопки **распределения** (Distribute) позволяют сделать одинаковые отступы между выделенными объектами.",
              },
              {
                // Новый этап
                order: 3, // Общий порядок 13
                type: "practice_fill_blank",
                title: "Практика: Группировка",
                content:
                  "Чтобы сгруппировать выделенные объекты, нужно нажать комбинацию клавиш Ctrl + ___ (или Cmd + ___).",
                correctAnswer: "G",
                explanation:
                  "Комбинация Ctrl+G (Cmd+G) используется для группировки объектов.",
              },
            ],
          },
          {
            // Новый урок
            id: "figma-l2-3",
            title: "Основы прототипирования",
            description: "Создание интерактивных связей между экранами",
            stages: [
              {
                order: 0, // Общий порядок 14
                type: "theory",
                title: "Что такое прототипирование?",
                content:
                  "Прототипирование в Figma позволяет сделать ваш дизайн интерактивным, имитируя работу реального приложения или сайта. Вы можете создавать переходы между экранами (фреймами) по клику или другим действиям.",
              },
              {
                order: 1, // Общий порядок 15
                type: "theory",
                title: "Создание простой связи",
                content:
                  "1. Перейдите во вкладку **Prototype** на правой панели.\n2. Выберите объект, по клику на который должен произойти переход (например, кнопку).\n3. У него появится кружок - потяните за него стрелку к фрейму, на который нужно перейти.\n4. Настройте анимацию перехода (по желанию).",
              },
              {
                order: 2, // Общий порядок 16
                type: "theory",
                title: "Итог курса", // Общий итог
                content:
                  "Поздравляю! Вы изучили самые основы Figma: интерфейс, работу с фреймами, фигурами, цветом, текстом, выравниванием, группировкой и даже создали простую интерактивную связь. Теперь у вас есть база для дальнейшего изучения!",
              },
            ],
          },
        ],
      },
    ],
  },
  {
    id: "web-development",
    title: "Основы веб-разработки: HTML, CSS, JavaScript", // Скорректировал
    description:
      "Изучите базовые технологии создания веб-сайтов: структуру (HTML), стили (CSS) и основы интерактивности (JavaScript).", // Скорректировал
    category: "Web-разработка",
    thumbnail: "web-development.jpg",
    totalLessons: 45, // Установлено ~45, будет уточнено
    modules: [
      // === Модуль 1: HTML - Структура ===
      {
        id: "html-module-1-condensed",
        title: "HTML: Структура страницы",
        description: "Создание скелета веб-страницы с помощью HTML",
        lessons: [
          {
            id: "html-l1-1-condensed",
            title: "Введение и базовые теги",
            description: "Структура документа, заголовки, параграфы, списки",
            stages: [
              // Этапы 0-3 (HTML, Теги, Атрибуты, Структура)
              {
                order: 0, // Общий 0
                type: "theory",
                title: "Что такое HTML?",
                content:
                  "HTML (HyperText Markup Language) — это язык разметки для создания структуры веб-страниц. Он как скелет для сайта.",
              },
              {
                order: 1, // Общий 1
                type: "theory",
                title: "Теги и атрибуты",
                content:
                  'HTML состоит из **тегов** (`<p>`, `<a>`) и их **атрибутов** (`href="..."`, `src="..."`), которые дают дополнительную информацию. Большинство тегов парные: `<p>текст</p>`.',
              },
              {
                order: 2, // Общий 2
                type: "theory",
                title: "Базовая структура HTML",
                content:
                  '```html\n<!DOCTYPE html>\n<html>\n<head>\n  <meta charset="UTF-8">\n  <title>Заголовок</title>\n</head>\n<body>\n  <!-- Видимый контент здесь -->\n</body>\n</html>\n```\n`<head>` - для метаинформации, `<body>` - для видимого контента.',
              },
              {
                order: 3, // Общий 3
                type: "practice_mcq",
                title: "Проверка: Структура",
                content: "Где размещается видимое содержимое страницы?",
                options: ["<head>", "<body>", "<title>", "<meta>"],
                correctAnswer: 1,
                explanation: "Тег `<body>` содержит все видимые элементы.",
              },
              {
                // Этапы 4-6 (Заголовки, Параграфы, Списки)
                order: 4, // Общий 4
                type: "theory",
                title: "Заголовки и Параграфы",
                content:
                  "Заголовки: `<h1>` (главный) - `<h6>`. Параграфы: `<p>`. Перенос строки: `<br>` (одиночный тег).",
              },
              {
                order: 5, // Общий 5
                type: "practice_code_input",
                title: "Практика: Заголовок и текст",
                content:
                  "Создайте главный заголовок 'Привет!' и под ним параграф 'Это мой сайт.'",
                correctAnswer: "<h1>Привет!</h1>\n<p>Это мой сайт.</p>",
                explanation: "Используйте теги `<h1>` и `<p>`.",
              },
              {
                order: 6, // Общий 6
                type: "theory",
                title: "Списки",
                content:
                  "Маркированный: `<ul><li>Элемент 1</li><li>Элемент 2</li></ul>`. Нумерованный: `<ol><li>...</li></ol>`. `<li>` - элемент списка.",
              },
              {
                order: 7, // Общий 7
                type: "practice_mcq",
                title: "Проверка: Списки",
                content:
                  "Какой тег обозначает ОДИН элемент нумерованного или маркированного списка?",
                options: ["<ul>", "<ol>", "<li>", "<list>"],
                correctAnswer: 2,
                explanation:
                  "Тег `<li>` (list item) используется для каждого элемента списка.",
              },
            ],
          },
          {
            id: "html-l1-2-condensed",
            title: "Ссылки, изображения и семантика",
            description: "Добавление контента и смысла в разметку",
            stages: [
              // Этапы 8-10 (Ссылки, Изображения)
              {
                order: 0, // Общий 8
                type: "theory",
                title: "Ссылки `<a>`",
                content:
                  'Тег `<a>` создает ссылки. Атрибут `href` указывает адрес. `target="_blank"` открывает в новой вкладке. `<a href="page.html">Текст ссылки</a>`',
              },
              {
                order: 1, // Общий 9
                type: "theory",
                title: "Изображения `<img>`",
                content:
                  'Тег `<img>` вставляет картинки (одиночный). Атрибут `src` - путь к файлу, `alt` - описание. `<img src="pic.jpg" alt="Описание">`',
              },
              {
                order: 2, // Общий 10
                type: "practice_code_input",
                title: "Практика: Картинка-ссылка",
                content:
                  "Сделайте картинку `logo.png` (с описанием 'Логотип') ссылкой на главную страницу `index.html`.",
                correctAnswer:
                  '<a href="index.html"><img src="logo.png" alt="Логотип"></a>',
                explanation: "Тег `<img>` вкладывается внутрь тега `<a>`.",
              },
              // Этапы 11-13 (Семантика)
              {
                order: 3, // Общий 11
                type: "theory",
                title: "Семантические теги",
                content:
                  "Используйте теги по смыслу: `<header>` (шапка), `<nav>` (навигация), `<main>` (основное содержимое), `<footer>` (подвал). Это улучшает понимание кода и доступность.",
              },
              {
                order: 4, // Общий 12
                type: "practice_mcq",
                title: "Проверка: Семантика",
                content: "Какой тег предназначен для 'подвала' сайта?",
                options: ["<bottom>", "<header>", "<footer>", "<main>"],
                correctAnswer: 2,
                explanation:
                  "Тег `<footer>` используется для нижней части страницы или раздела.",
              },
              // Этап 14 (Форма)
              {
                order: 5, // Общий 13
                type: "theory",
                title: "Простая форма",
                content:
                  'Формы `<form>` используются для сбора данных. Основные элементы: `<input type="text">` (текстовое поле), `<button type="submit">Отправить</button>` (кнопка отправки).',
              },
              {
                order: 6, // Общий 14
                type: "practice_code_input",
                title: "Практика: Форма",
                content:
                  "Создайте форму с полем для ввода email (`type=\"email\"`) и кнопкой 'Подписаться'.",
                correctAnswer:
                  '<form>\n  <input type="email" placeholder="Ваш email">\n  <button type="submit">Подписаться</button>\n</form>',
                explanation:
                  'Используйте `<form>`, `<input type="email">` и `<button>`.',
              },
            ],
          },
        ],
      },
      // === Модуль 2: CSS - Стилизация ===
      {
        id: "css-module-1-condensed",
        title: "CSS: Стилизация страницы",
        description: "Оформление HTML-элементов с помощью CSS",
        lessons: [
          {
            id: "css-l1-1-condensed",
            title: "Подключение и селекторы",
            description: "Как добавить стили и выбрать нужные элементы",
            stages: [
              // Этапы 0-3 (Подключение, Синтаксис, Селекторы)
              {
                order: 0, // Общий 15
                type: "theory",
                title: "Подключение CSS",
                content:
                  'CSS (Cascading Style Sheets) отвечает за внешний вид. Лучше всего создавать отдельный `style.css` файл и подключать его в `<head>` HTML: `<link rel="stylesheet" href="style.css">`',
              },
              {
                order: 1, // Общий 16
                type: "theory",
                title: "Синтаксис CSS",
                content:
                  "Правило CSS: `селектор { свойство: значение; }`. Селектор выбирает HTML-элемент, свойство - что меняем, значение - как меняем. Пример: `p { color: blue; }`",
              },
              {
                order: 2, // Общий 17
                type: "theory",
                title: "Основные селекторы",
                content:
                  '- **По тегу:** `p`, `h1`\n- **По классу:** `.my-class` (для `<p class="my-class">`)\n- **По ID:** `#my-id` (для `<div id="my-id">`, ID должен быть уникальным!)',
              },
              {
                order: 3, // Общий 18
                type: "practice_mcq",
                title: "Проверка: Селекторы",
                content: "Каким символом начинается селектор по ID?",
                options: [".", "#", "$", "*"],
                correctAnswer: 1,
                explanation: "Селектор по ID начинается с символа решетки `#`.",
              },
            ],
          },
          {
            id: "css-l1-2-condensed",
            title: "Цвет, фон и шрифт",
            description: "Работа с цветом и текстом",
            stages: [
              // Этапы 4-7 (Цвет, Фон, Шрифт)
              {
                order: 0, // Общий 19
                type: "theory",
                title: "Цвет и Фон",
                content:
                  "- `color`: Задает цвет текста (например, `color: red;`, `color: #333;`).\n- `background-color`: Задает цвет фона (например, `background-color: lightblue;`).",
              },
              {
                order: 1, // Общий 20
                type: "practice_code_input",
                title: "Практика: Цвет",
                content:
                  "Сделайте текст всех ссылок (`<a>`) зеленым (`green`).",
                correctAnswer: "a {\n  color: green;\n}",
                explanation:
                  "Используйте селектор тега `a` и свойство `color`.",
              },
              {
                order: 2, // Общий 21
                type: "theory",
                title: "Шрифт",
                content:
                  "- `font-family`: Название шрифта (`font-family: Arial, sans-serif;`).\n- `font-size`: Размер (`font-size: 16px;`, `font-size: 1.2em;`).\n- `font-weight`: Жирность (`font-weight: bold;`, `font-weight: 400;`).",
              },
              {
                order: 3, // Общий 22
                type: "practice_code_input",
                title: "Практика: Шрифт",
                content:
                  "Задайте для всего `body` шрифт 'Verdana' размером 14px.",
                correctAnswer:
                  "body {\n  font-family: Verdana, sans-serif;\n  font-size: 14px;\n}",
                explanation:
                  "Применение стилей к `body` повлияет на большинство элементов внутри.",
              },
            ],
          },
          {
            id: "css-l1-3-condensed",
            title: "Отступы и рамки",
            description:
              "Управление пространством вокруг элементов (Box Model)",
            stages: [
              // Этапы 8-11 (Box Model, Padding, Margin, Border)
              {
                order: 0, // Общий 23
                type: "theory",
                title: "Блочная модель (Box Model)",
                content:
                  "Элемент - это 'коробка': контент + внутренние поля (`padding`) + рамка (`border`) + внешние отступы (`margin`).",
              },
              {
                order: 1, // Общий 24
                type: "theory",
                title: "Padding и Margin",
                content:
                  "- `padding`: Отступ ВНУТРИ рамки (от контента до рамки). `padding: 10px;`\n- `margin`: Отступ СНАРУЖИ рамки (от рамки до соседей). `margin: 15px;` \nМожно задавать для каждой стороны: `padding-top`, `margin-bottom` и т.д.",
              },
              {
                order: 2, // Общий 25
                type: "theory",
                title: "Border",
                content:
                  "Рамка вокруг элемента. `border: толщина стиль цвет;`. Пример: `border: 1px solid gray;` (серая сплошная рамка 1px).",
              },
              {
                order: 3, // Общий 26
                type: "practice_code_input",
                title: "Практика: Отступы",
                content:
                  "Для элемента с классом `card` задайте внутренние отступы 20px и внешний отступ снизу 10px.",
                correctAnswer:
                  ".card {\n  padding: 20px;\n  margin-bottom: 10px;\n}",
                explanation:
                  "Используйте свойства `padding` и `margin-bottom`.",
              },
              // Этап 12 (Введение в Flex)
              {
                order: 4, // Общий 27
                type: "theory",
                title: "Введение в Layout: display: flex",
                content:
                  "Чтобы расположить дочерние элементы в строку, задайте родительскому контейнеру `display: flex;`. Это включает режим Flexbox. Подробнее о Flexbox - в следующих курсах или самостоятельно!",
              },
              {
                order: 5, // Общий 28
                type: "practice_code_input",
                title: "Практика: Flex",
                content:
                  'Как сделать, чтобы элементы внутри `<div class="row">` выстроились в ряд?',
                correctAnswer: ".row {\n  display: flex;\n}",
                explanation:
                  "Свойство `display: flex;` делает контейнер flex-контейнером.",
              },
            ],
          },
        ],
      },
      // === Модуль 3: JavaScript - Основы ===
      {
        id: "js-module-1-condensed",
        title: "JavaScript: Основы интерактивности",
        description: "Добавление простого поведения на страницу",
        lessons: [
          {
            id: "js-l1-1-condensed",
            title: "Введение и переменные",
            description: "Подключение JS, консоль, хранение данных",
            stages: [
              // Этапы 0-3 (Что такое JS, Подключение, Консоль)
              {
                order: 0, // Общий 29
                type: "theory",
                title: "JavaScript (JS)",
                content:
                  "JS делает страницы 'живыми': реагирует на действия, меняет контент без перезагрузки. Подключается тегом `<script src=\"script.js\"></script>` обычно перед `</body>`.",
              },
              {
                order: 1, // Общий 30
                type: "theory",
                title: "Консоль разработчика (F12)",
                content:
                  "Используйте вкладку 'Console' для отладки. Функция `console.log('Сообщение');` выводит текст или значение переменной в консоль.",
              },
              {
                order: 2, // Общий 31
                type: "practice_code_input",
                title: "Практика: Консоль",
                content: "Напишите JS-код для вывода 'Hello JS!' в консоль.",
                correctAnswer: "console.log('Hello JS!');",
                explanation: "Используйте `console.log()`.",
              },
              // Этапы 4-6 (Переменные, Типы)
              {
                order: 3, // Общий 32
                type: "theory",
                title: "Переменные: let и const",
                content:
                  "Переменные хранят данные. Используйте `let` для переменных, значение которых может меняться, и `const` для констант (неизменяемых значений).\n`let message = 'Привет';`\n`const year = 2024;`",
              },
              {
                order: 4, // Общий 33
                type: "theory",
                title: "Базовые типы данных",
                content:
                  "- **String:** Текст в кавычках ('Привет', \"Мир\").\n- **Number:** Числа (10, 3.14).\n- **Boolean:** Логические значения (`true`, `false`).",
              },
              {
                order: 5, // Общий 34
                type: "practice_mcq",
                title: "Проверка: Типы",
                content: "К какому типу данных относится значение `true`?",
                options: ["String", "Number", "Boolean", "Undefined"],
                correctAnswer: 2,
                explanation:
                  "`true` и `false` - это значения булева (логического) типа.",
              },
            ],
          },
          {
            id: "js-l1-2-condensed",
            title: "Работа с DOM",
            description: "Изменение HTML-элементов с помощью JavaScript",
            stages: [
              // Этапы 7-10 (DOM, getElementById, textContent)
              {
                order: 0, // Общий 35
                type: "theory",
                title: "DOM (Document Object Model)",
                content:
                  "Браузер представляет HTML-страницу как дерево объектов (DOM). JavaScript может получать доступ к этим объектам (элементам) и изменять их.",
              },
              {
                order: 1, // Общий 36
                type: "theory",
                title: "Получение элемента по ID",
                content:
                  "Чтобы получить доступ к элементу, у которого есть уникальный `id` (например, `<p id=\"message\">`), используется метод `document.getElementById('имя_id')`.\n`let messageElement = document.getElementById('message');`",
              },
              {
                order: 2, // Общий 37
                type: "theory",
                title: "Изменение текста: textContent",
                content:
                  "Получив элемент, можно изменить его текстовое содержимое с помощью свойства `textContent`.\n`messageElement.textContent = 'Новый текст!';`",
              },
              {
                order: 3, // Общий 38
                type: "practice_code_input",
                title: "Практика: Изменение текста",
                content:
                  "Найдите элемент с ID `user-greeting` и измените его текст на 'Добро пожаловать!'.",
                correctAnswer:
                  "let greeting = document.getElementById('user-greeting');\ngreeting.textContent = 'Добро пожаловать!';",
                explanation:
                  "Сначала получаем элемент, потом меняем его `textContent`.",
              },
              {
                order: 4, // Общий 39
                type: "theory",
                title: "Изменение стилей: style",
                content:
                  "Можно менять CSS-стили элемента через свойство `style`. CSS-свойства пишутся в camelCase (например, `backgroundColor`).\n`messageElement.style.color = 'red';`\n`messageElement.style.backgroundColor = '#eee';`",
              },
            ],
          },
          {
            id: "js-l1-3-condensed",
            title: "События",
            description: "Реакция на действия пользователя",
            stages: [
              // Этапы 11-14 (События, addEventListener, click)
              {
                order: 0, // Общий 40
                type: "theory",
                title: "Что такое события?",
                content:
                  "События — это действия, которые происходят на странице (клик мыши, нажатие клавиши, загрузка страницы). JavaScript может 'слушать' эти события и выполнять код в ответ.",
              },
              {
                order: 1, // Общий 41
                type: "theory",
                title: "Обработчик событий: addEventListener",
                content:
                  "Чтобы 'повесить' реакцию на событие на элемент, используется метод `addEventListener('имя_события', функция_обработчик)`. Функция-обработчик — это код, который выполнится при событии.",
              },
              {
                order: 2, // Общий 42
                type: "theory",
                title: "Событие клика (click)",
                content:
                  "Пример: при клике на кнопку с ID `myButton` выводить сообщение в консоль.\n```javascript\nlet myButton = document.getElementById('myButton');\n\nmyButton.addEventListener('click', function() {\n  console.log('Кнопка нажата!');\n  // Здесь можно добавить другой код\n});\n```",
              },
              {
                order: 3, // Общий 43
                type: "practice_code_input",
                title: "Практика: Обработка клика",
                content:
                  "Найдите кнопку с ID `alertButton` и сделайте так, чтобы при клике на нее менялся текст параграфа с ID `statusText` на 'Кнопка была нажата'.",
                correctAnswer:
                  "let btn = document.getElementById('alertButton');\nlet status = document.getElementById('statusText');\n\nbtn.addEventListener('click', function() {\n  status.textContent = 'Кнопка была нажата';\n});",
                explanation:
                  "Нужно получить оба элемента и внутри обработчика клика кнопки изменить `textContent` параграфа.",
              },
              {
                order: 4, // Общий 44
                type: "theory",
                title: "Итог по JavaScript",
                content:
                  "Мы познакомились с основами JS: как подключить, вывести в консоль, использовать переменные, изменять элементы страницы (DOM) и реагировать на клики пользователя (события). Это база для создания интерактивных сайтов!",
              },
            ],
          },
        ],
      },
    ],
  },
  {
    id: "javascript",
    title: "Углубленный JavaScript",
    description:
      "Погружение в продвинутые концепции JavaScript: функции, прототипы, асинхронность и ES6+.",
    category: "Программирование",
    thumbnail: "javascript.jpg", // Исправлено имя файла картинки
    totalLessons: 25, // Ориентировочное количество
    modules: [
      // === Модуль 1: Продвинутые функции ===
      {
        id: "advjs-m1",
        title: "Продвинутые функции",
        description: "Замыкания, контекст вызова, рекурсия",
        lessons: [
          {
            id: "advjs-l1-1",
            title: "Замыкания и this",
            stages: [
              {
                order: 0, // Общий 0
                type: "theory",
                title: "Замыкания (Closures)",
                content:
                  "Замыкание — это функция вместе со ссылками на переменные из её внешней лексической среды. Проще говоря, функция 'помнит' переменные там, где она была создана, даже если вызвана в другом месте.\n```javascript\nfunction outer() {\n  let count = 0;\n  return function inner() {\n    count++;\n    console.log(count);\n  };\n}\nlet counter = outer();\ncounter(); // 1\ncounter(); // 2\n```",
              },
              {
                order: 1, // Общий 1
                type: "practice_mcq",
                title: "Проверка: Замыкания",
                content:
                  "Что будет выведено в консоль?\n```javascript\nfunction createAdder(x) {\n  return function(y) {\n    return x + y;\n  };\n}\nlet add5 = createAdder(5);\nconsole.log(add5(3));\n```",
                options: ["3", "5", "8", "Ошибка"],
                correctAnswer: 2,
                explanation:
                  "Функция `add5` замкнула значение `x=5` из `createAdder` и добавила к нему `y=3`.",
              },
              {
                order: 2, // Общий 2
                type: "theory",
                title: "Ключевое слово `this`",
                content:
                  "`this` указывает на контекст вызова функции. Его значение определяется тем, *как* функция вызвана:\n- **Глобальный контекст (не 'use strict'):** `window` (в браузере) или `global` (Node.js).\n- **Метод объекта:** `obj.method()` -> `this` указывает на `obj`.\n- **Функция-конструктор:** `new Func()` -> `this` указывает на новый создаваемый объект.\n- **Стрелочные функции:** `this` берется из внешней (окружающей) лексической среды, не имеет своего `this`.",
              },
              {
                order: 3, // Общий 3
                type: "practice_fill_blank",
                title: "Проверка: this",
                content:
                  "При вызове метода объекта `user.sayHi()`, `this` внутри `sayHi` будет ссылаться на ______. ",
                correctAnswer: "user",
                explanation:
                  "При вызове метода `объект.метод()`, `this` указывает на сам `объект`.",
              },
              {
                order: 4, // Общий 4
                type: "theory",
                title: "Методы `call`, `apply`, `bind`",
                content:
                  "Позволяют вручную установить значение `this` для функции:\n- `func.call(context, arg1, arg2)`: Вызывает `func` с `this = context` и аргументами `arg1`, `arg2`.\n- `func.apply(context, [arg1, arg2])`: То же, но аргументы передаются массивом.\n- `func.bind(context, arg1)`: Возвращает *новую* функцию, у которой `this` навсегда привязан к `context`, а первые аргументы 'зафиксированы'.",
              },
              {
                order: 5, // Общий 5
                type: "practice_code_input",
                title: "Практика: bind",
                content:
                  "Дан объект `user = { name: 'Петя' }` и функция `function greet() { console.log('Привет, ' + this.name); }`. Создайте новую функцию `greetUser`, которая всегда будет выводить приветствие для `user`, используя `bind`.",
                correctAnswer: "let greetUser = greet.bind(user);",
                explanation:
                  "`bind` создает новую функцию с привязанным контекстом.",
              },
            ],
          },
        ],
      },
      // === Модуль 2: Прототипы и Классы ===
      {
        id: "advjs-m2",
        title: "Прототипы и Классы",
        description: "Объекты, наследование и синтаксис классов ES6",
        lessons: [
          {
            id: "advjs-l2-1",
            title: "Прототипы и классы",
            stages: [
              {
                order: 0, // Общий 6
                type: "theory",
                title: "Прототипное наследование",
                content:
                  "В JavaScript объекты могут наследовать свойства и методы от других объектов через цепочку прототипов. Свойство `__proto__` (нестандартное, но распространенное) или метод `Object.getPrototypeOf()` указывает на прототип объекта. `Object.create(proto)` создает новый объект с указанным прототипом.",
              },
              {
                order: 1, // Общий 7
                type: "practice_mcq",
                title: "Проверка: Прототипы",
                content:
                  "Как называется механизм, позволяющий объектам в JS наследовать свойства друг от друга?",
                options: [
                  "Классовое наследование",
                  "Замыкание",
                  "Прототипное наследование",
                  "Делегирование",
                ],
                correctAnswer: 2,
                explanation: "JavaScript использует прототипное наследование.",
              },
              {
                order: 2, // Общий 8
                type: "theory",
                title: "Классы ES6 (Введение)",
                content:
                  "Классы - это синтаксический сахар над прототипным наследованием. Синтаксис:\n```javascript\nclass User {\n  constructor(name) {\n    this.name = name;\n  }\n  sayHi() {\n    console.log(`Привет, ${this.name}!`);\n  }\n}\nlet user = new User('Вася');\nuser.sayHi(); // Привет, Вася!\n```\n`constructor` - специальный метод для инициализации объекта.",
              },
              {
                order: 3, // Общий 9
                type: "practice_code_input",
                title: "Практика: Класс",
                content:
                  "Создайте класс `Rectangle` с конструктором, принимающим `width` и `height`, и методом `getArea()`, возвращающим площадь.",
                correctAnswer:
                  "class Rectangle {\n  constructor(width, height) {\n    this.width = width;\n    this.height = height;\n  }\n  getArea() {\n    return this.width * this.height;\n  }\n}",
                explanation:
                  "Класс определяется с помощью `class`, конструктор - `constructor`, методы объявляются внутри класса.",
              },
              {
                order: 4, // Общий 10
                type: "theory",
                title: "Наследование классов (`extends`, `super`)",
                content:
                  "Классы могут наследоваться друг от друга с помощью `extends`. В конструкторе дочернего класса нужно вызвать `super()` для вызова конструктора родителя.\n```javascript\nclass Animal {\n  constructor(name) { this.name = name; }\n}\nclass Rabbit extends Animal {\n  constructor(name) {\n    super(name); // Вызов конструктора Animal\n    this.type = 'Кролик';\n  }\n}\n```",
              },
              {
                order: 5, // Общий 11
                type: "theory",
                title: "Статические и приватные члены",
                content:
                  "- **Статические** методы/свойства принадлежат самому классу, а не его экземплярам (`static myMethod()`). Вызываются как `ClassName.myMethod()`.\n- **Приватные** поля/методы начинаются с `#` (`#privateField`). Доступны только внутри класса.",
              },
            ],
          },
        ],
      },
      // === Модуль 3: Асинхронный JavaScript ===
      {
        id: "advjs-m3",
        title: "Асинхронный JavaScript",
        description: "Callbacks, Promises, async/await, Event Loop",
        lessons: [
          {
            id: "advjs-l3-1",
            title: "Callbacks и Promises",
            stages: [
              {
                order: 0, // Общий 12
                type: "theory",
                title: "Асинхронность и Event Loop",
                content:
                  "JavaScript однопоточный, но выполняет асинхронные операции (сетевые запросы, таймеры) с помощью Web API браузера/Node.js и цикла событий (Event Loop), который помещает колбэки в очередь на выполнение, когда основной поток свободен.",
              },
              {
                order: 1, // Общий 13
                type: "theory",
                title: "Callbacks и 'Callback Hell'",
                content:
                  "Callback - функция, передаваемая как аргумент другой функции, чтобы быть вызванной позже. Глубокая вложенность колбэков ('Callback Hell') затрудняет чтение и поддержку кода.",
              },
              {
                order: 2, // Общий 14
                type: "theory",
                title: "Promises: Основы",
                content:
                  "Promise - объект, представляющий результат асинхронной операции (успех или ошибка). Состояния: `pending`, `fulfilled`, `rejected`. Методы:\n- `.then(onFulfilled, onRejected)`: Обработка успеха/ошибки.\n- `.catch(onRejected)`: Обработка только ошибки.\n- `.finally(onFinally)`: Выполняется всегда.",
              },
              {
                order: 3, // Общий 15
                type: "practice_code_input",
                title: "Практика: Promise",
                content:
                  "Создайте Promise, который успешно разрешается со значением 'Готово!' через 1 секунду (используйте `setTimeout`).",
                correctAnswer:
                  "let promise = new Promise((resolve, reject) => {\n  setTimeout(() => resolve('Готово!'), 1000);\n});",
                explanation:
                  "Конструктор Promise принимает функцию с аргументами `resolve` и `reject`.",
              },
              {
                order: 4, // Общий 16
                type: "theory",
                title: "Цепочки Promises и Promise.all/race",
                content:
                  "`.then()` возвращает новый Promise, позволяя создавать цепочки. \n- `Promise.all([p1, p2])`: Ждет выполнения всех промисов. Ошибка в одном - отклоняет весь результат.\n- `Promise.race([p1, p2])`: Ждет выполнения *первого* (успех или ошибка) промиса.",
              },
            ],
          },
          {
            id: "advjs-l3-2",
            title: "Async/Await",
            stages: [
              {
                order: 0, // Общий 17
                type: "theory",
                title: "Синтаксис `async/await`",
                content:
                  "`async/await` - удобный синтаксис для работы с Promises. \n- `async function myFunc() { ... }`: Объявляет асинхронную функцию (всегда возвращает Promise).\n- `await promise`: Приостанавливает выполнение `async` функции до разрешения `promise` и возвращает его результат.",
              },
              {
                order: 1, // Общий 18
                type: "practice_mcq",
                title: "Проверка: async/await",
                content:
                  "Что обязательно должна делать функция, чтобы внутри нее можно было использовать `await`?",
                options: [
                  "Возвращать Promise",
                  "Быть объявлена с `async`",
                  "Принимать callback",
                  "Иметь блок `try...catch`",
                ],
                correctAnswer: 1,
                explanation:
                  "Оператор `await` можно использовать только внутри функций, объявленных с ключевым словом `async`.",
              },
              {
                order: 2, // Общий 19
                type: "theory",
                title: "Обработка ошибок с `async/await`",
                content:
                  "Ошибки в Promises, ожидаемых через `await`, можно ловить с помощью стандартного блока `try...catch`.\n```javascript\nasync function fetchData() {\n  try {\n    let response = await fetch('/api/data');\n    let data = await response.json();\n    console.log(data);\n  } catch (error) {\n    console.error('Ошибка:', error);\n  }\n}\n```",
              },
            ],
          },
        ],
      },
      // === Модуль 4: Модули и Продвинутые возможности ===
      {
        id: "advjs-m4",
        title: "Модули и Продвинутые возможности",
        description: "ES6 Модули, ошибки, методы массивов, деструктуризация",
        lessons: [
          {
            id: "advjs-l4-1",
            title: "Модули, Ошибки, Массивы",
            stages: [
              {
                order: 0, // Общий 20
                type: "theory",
                title: "ES6 Модули (`import`/`export`)",
                content:
                  "Позволяют разбивать код на файлы (модули) и использовать код из других файлов.\n- `export let name = ...;` / `export default ...;`: Экспорт переменных/функций/классов.\n- `import { name } from './module.js';` / `import defaultExport from './module.js';`: Импорт.",
              },
              {
                order: 1, // Общий 21
                type: "theory",
                title: "Обработка ошибок (`try...catch`)",
                content:
                  "Блок `try` позволяет выполнить код, который может вызвать ошибку. Блок `catch(err)` ловит ошибку, если она произошла. Блок `finally` выполняется всегда, независимо от ошибки. Можно создавать свои ошибки: `throw new Error('Сообщение');`",
              },
              {
                order: 2, // Общий 22
                type: "theory",
                title: "Продвинутые методы массивов",
                content:
                  "- `map(fn)`: Создает новый массив, применив `fn` к каждому элементу.\n- `filter(fn)`: Создает новый массив из элементов, для которых `fn` вернула `true`.\n- `reduce(fn, initialValue)`: 'Сворачивает' массив в одно значение.",
              },
              {
                order: 3, // Общий 23
                type: "practice_code_input",
                title: "Практика: map",
                content:
                  "Дан массив `numbers = [1, 2, 3]`. Используя `map`, создайте новый массив `doubled`, где каждый элемент удвоен.",
                correctAnswer: "let doubled = numbers.map(num => num * 2);",
                explanation:
                  "Метод `map` создает новый массив на основе результатов вызова функции для каждого элемента исходного.",
              },
            ],
          },
          {
            id: "advjs-l4-2",
            title: "Деструктуризация",
            stages: [
              {
                order: 0, // Общий 24
                type: "theory",
                title: "Деструктуризация",
                content:
                  "Удобный синтаксис для извлечения значений из массивов или свойств объектов в отдельные переменные.\n- **Массивы:** `let [a, b] = [1, 2];`\n- **Объекты:** `let { name, age } = { name: 'Имя', age: 25 };`\nМожно задавать значения по умолчанию и переименовывать переменные.",
              },
              {
                order: 1, // Общий 25
                type: "practice_code_input",
                title: "Практика: Деструктуризация объекта",
                content:
                  "Дан объект `const user = { id: 1, username: 'tester' };`. Извлеките `username` в отдельную переменную с помощью деструктуризации.",
                correctAnswer: "let { username } = user;",
                explanation:
                  "Фигурные скобки используются для деструктуризации объекта по именам свойств.",
              },
            ],
          },
        ],
      },
    ],
  },
  {
    id: "nodejs",
    title: "Node.js: Основы бэкенда",
    description:
      "Изучите основы Node.js для создания серверных приложений, включая работу с модулями, NPM, HTTP и фреймворком Express.",
    category: "Программирование",
    thumbnail: "nodejs.png", // Убедись, что картинка есть в public/images/
    totalLessons: 28, // Расчетное количество
    modules: [
      // === Модуль 1: Введение и Основные Модули ===
      {
        id: "node-m1",
        title: "Введение и Основные Модули",
        description: "Что такое Node.js, Event Loop, модули fs и path",
        lessons: [
          {
            id: "node-l1-1",
            title: "Основы Node.js и Модули",
            stages: [
              {
                order: 0, // Общий 0
                type: "theory",
                title: "Что такое Node.js?",
                content:
                  "Node.js — это среда выполнения JavaScript на сервере, построенная на движке V8 (из Google Chrome). Она позволяет использовать JavaScript для бэкенд-разработки. Ключевая особенность - неблокирующий ввод-вывод (non-blocking I/O) и цикл событий (Event Loop), что делает её эффективной для обработки множества одновременных соединений.",
              },
              {
                order: 1, // Общий 1
                type: "theory",
                title: "REPL и Запуск Скриптов",
                content:
                  "- **REPL (Read-Eval-Print Loop):** Интерактивная консоль Node.js (запускается командой `node` без аргументов). Удобна для быстрых экспериментов.\n- **Запуск скрипта:** Сохраните JS-код в файл (например, `app.js`) и запустите его командой `node app.js`.",
              },
              {
                order: 2, // Общий 2
                type: "theory",
                title: "Основные встроенные модули",
                content:
                  "Node.js поставляется с набором встроенных модулей. Для их использования нужен `require()`:\n- `const fs = require('fs');` // Файловая система\n- `const path = require('path');` // Работа с путями\n- `const http = require('http');` // Создание HTTP-серверов",
              },
              {
                order: 3, // Общий 3
                type: "theory",
                title: "Модуль `fs` (File System)",
                content:
                  "Модуль `fs` позволяет работать с файловой системой. Большинство его методов имеют синхронные и асинхронные (с колбэками или возвращающие Promise) версии. Всегда предпочитайте асинхронные!\n- `fs.readFile(path, encoding, callback)`: Асинхронное чтение файла.\n- `fs.writeFile(path, data, callback)`: Асинхронная запись файла.",
              },
              {
                order: 4, // Общий 4
                type: "practice_mcq",
                title: "Проверка: fs",
                content:
                  "Какой метод модуля `fs` предпочтительнее использовать для чтения файла в Node.js приложении?",
                options: ["readFileSync", "readFile", "openSync", "readStream"],
                correctAnswer: 1,
                explanation:
                  "Асинхронный `readFile` не блокирует Event Loop, в отличие от `readFileSync`.",
              },
              {
                order: 5, // Общий 5
                type: "theory",
                title: "Модуль `path`",
                content:
                  "Модуль `path` предоставляет утилиты для работы с путями к файлам и каталогам.\n- `path.join([...paths])`: Объединяет сегменты пути, используя правильный разделитель для ОС.\n- `path.resolve([...paths])`: Преобразует путь в абсолютный.\n- `path.basename(path)`: Возвращает последнюю часть пути (имя файла).\n- `__dirname`: Глобальная переменная, содержащая путь к каталогу текущего выполняемого скрипта.",
              },
              {
                order: 6, // Общий 6
                type: "practice_code_input",
                title: "Практика: path.join",
                content:
                  "Используя модуль `path` и `__dirname`, создайте путь к файлу `data.txt`, который находится в той же папке, что и текущий скрипт.",
                correctAnswer:
                  "const path = require('path');\nconst filePath = path.join(__dirname, 'data.txt');",
                explanation:
                  "`path.join` корректно объединяет путь к директории скрипта и имя файла.",
              },
            ],
          },
        ],
      },
      // === Модуль 2: NPM и Модули ===
      {
        id: "node-m2",
        title: "NPM и Пакеты",
        description: "Управление зависимостями с помощью NPM",
        lessons: [
          {
            id: "node-l2-1",
            title: "Основы NPM",
            stages: [
              {
                order: 0, // Общий 7
                type: "theory",
                title: "Что такое NPM?",
                content:
                  "NPM (Node Package Manager) — это менеджер пакетов для Node.js. Он позволяет:\n- Устанавливать сторонние библиотеки (пакеты).\n- Управлять зависимостями проекта.\n- Публиковать свои пакеты.",
              },
              {
                order: 1, // Общий 8
                type: "theory",
                title: "`package.json` и `npm init`",
                content:
                  "`package.json` — это файл манифеста проекта. Он содержит метаданные (имя, версия) и списки зависимостей.\n- Команда `npm init` (или `npm init -y` для настроек по умолчанию) создает `package.json` в текущей папке.",
              },
              {
                order: 2, // Общий 9
                type: "theory",
                title: "Установка пакетов (`npm install`)",
                content:
                  "- `npm install <имя_пакета>`: Устанавливает пакет и добавляет его в `dependencies` в `package.json` (зависимости для работы приложения).\n- `npm install <имя_пакета> --save-dev` (или `-D`): Устанавливает пакет и добавляет его в `devDependencies` (зависимости для разработки, например, линтеры, тест-фреймворки).\n- `npm install`: Устанавливает все зависимости из `package.json`.",
              },
              {
                order: 3, // Общий 10
                type: "practice_fill_blank",
                title: "Проверка: Установка",
                content:
                  "Команда `npm ______ lodash` установит библиотеку lodash как зависимость проекта.",
                correctAnswer: "install",
                explanation:
                  "`npm install <package>` используется для установки пакетов.",
              },
              {
                order: 4, // Общий 11
                type: "theory",
                title: "Использование пакета",
                content:
                  "После установки пакет можно использовать в коде с помощью `require()`:\n```javascript\n// Установив lodash: npm install lodash\nconst _ = require('lodash');\n\nconst arr = [1, 2, 3];\nconsole.log(_.shuffle(arr)); // Выведет перемешанный массив\n```",
              },
            ],
          },
        ],
      },
      // === Модуль 3: Модуль HTTP и Сервер ===
      {
        id: "node-m3",
        title: "Модуль HTTP и Сервер",
        description: "Создание простого веб-сервера на Node.js",
        lessons: [
          {
            id: "node-l3-1",
            title: "HTTP Сервер",
            stages: [
              {
                order: 0, // Общий 12
                type: "theory",
                title: "Модуль `http`",
                content:
                  "Модуль `http` позволяет создавать HTTP-серверы.\n```javascript\nconst http = require('http');\n\nconst server = http.createServer((req, res) => {\n  // Обработка запроса (req) и отправка ответа (res)\n  res.statusCode = 200;\n  res.setHeader('Content-Type', 'text/plain');\n  res.end('Hello World\\n');\n});\n\nserver.listen(3000, '127.0.0.1', () => {\n  console.log('Сервер запущен на http://127.0.0.1:3000/');\n});\n```",
              },
              {
                order: 1, // Общий 13
                type: "theory",
                title: "Объекты `request` (req) и `response` (res)",
                content:
                  "Функция, передаваемая в `http.createServer`, получает два аргумента:\n- `req` (IncomingMessage): Объект запроса. Содержит информацию о запросе (URL, метод, заголовки).\n- `res` (ServerResponse): Объект ответа. Используется для отправки ответа клиенту (статус, заголовки, тело).",
              },
              {
                order: 2, // Общий 14
                type: "theory",
                title: "Отправка ответа",
                content:
                  "- `res.statusCode = 200;`: Установка HTTP статус-кода.\n- `res.setHeader('Header-Name', 'value');`: Установка заголовка ответа.\n- `res.write('часть тела');`: Запись части тела ответа.\n- `res.end('финальная часть или всё тело');`: Завершает ответ и отправляет его. Обязательно вызвать!",
              },
              {
                order: 3, // Общий 15
                type: "practice_code_input",
                title: "Практика: Заголовки",
                content:
                  "Как установить заголовок ответа `Content-Type` в `application/json`?",
                correctAnswer:
                  "res.setHeader('Content-Type', 'application/json');",
                explanation:
                  "Метод `res.setHeader(name, value)` устанавливает заголовок.",
              },
              {
                order: 4, // Общий 16
                type: "theory",
                title: "Простая Маршрутизация",
                content:
                  "Можно проверять `req.url` и `req.method`, чтобы отправлять разные ответы для разных URL и методов.\n```javascript\nhttp.createServer((req, res) => {\n  if (req.url === '/' && req.method === 'GET') {\n    res.end('Главная страница');\n  } else if (req.url === '/about') {\n    res.end('О нас');\n  } else {\n    res.statusCode = 404;\n    res.end('Не найдено');\n  }\n}).listen(3000);\n```",
              },
              {
                order: 5, // Общий 17
                type: "practice_mcq",
                title: "Проверка: Маршрутизация",
                content:
                  "Какое свойство объекта `req` обычно используется для определения запрошенного пути?",
                options: ["req.path", "req.route", "req.url", "req.uri"],
                correctAnswer: 2,
                explanation:
                  "Свойство `req.url` содержит запрошенный URL (путь и параметры).",
              },
              {
                order: 6, // Общий 18
                type: "theory",
                title: "Чтение Query Parameters",
                content:
                  "Параметры URL (после `?`, например `/search?q=node`) можно разобрать с помощью модуля `url`.\n```javascript\nconst url = require('url');\nconst queryParams = url.parse(req.url, true).query;\n// queryParams будет объектом { q: 'node' }\n```",
              },
              {
                order: 7, // Общий 19
                type: "practice_code_input",
                title: "Практика: HTTP Сервер",
                content:
                  "Создайте минимальный HTTP сервер, который на любой GET запрос отвечает текстом 'OK'.",
                correctAnswer:
                  "const http = require('http');\n\nhttp.createServer((req, res) => {\n  res.statusCode = 200;\n  res.setHeader('Content-Type', 'text/plain');\n  res.end('OK');\n}).listen(3000);",
                explanation: "Используем `http.createServer` и `res.end()`.",
              },
            ],
          },
        ],
      },
      // === Модуль 4: Введение в Express ===
      {
        id: "node-m4",
        title: "Введение в Express",
        description: "Создание веб-приложений с помощью фреймворка Express",
        lessons: [
          {
            id: "node-l4-1",
            title: "Express: Основы",
            stages: [
              {
                order: 0, // Общий 20
                type: "theory",
                title: "Что такое Express?",
                content:
                  "Express.js — это минималистичный и гибкий веб-фреймворк для Node.js. Он упрощает создание веб-серверов и API, предоставляя удобные инструменты для маршрутизации, обработки запросов/ответов и работы с middleware.",
              },
              {
                order: 1, // Общий 21
                type: "theory",
                title: "Установка и Настройка",
                content:
                  "1. `npm init -y`\n2. `npm install express`\n3. Создаем файл `app.js`:\n```javascript\nconst express = require('express');\nconst app = express();\nconst port = 3000;\n\napp.get('/', (req, res) => {\n  res.send('Привет от Express!');\n});\n\napp.listen(port, () => {\n  console.log(`Сервер запущен на http://localhost:${port}`);\n});\n```",
              },
              {
                order: 2, // Общий 22
                type: "theory",
                title: "Маршрутизация в Express",
                content:
                  "Express предоставляет методы для обработки разных HTTP-методов:\n- `app.get(path, handler)`\n- `app.post(path, handler)`\n- `app.put(path, handler)`\n- `app.delete(path, handler)`\n`handler` - это функция `(req, res) => { ... }`.",
              },
              {
                order: 3, // Общий 23
                type: "practice_mcq",
                title: "Проверка: Маршрутизация",
                content:
                  "Какой метод Express используется для обработки GET-запросов по пути `/users`?",
                options: [
                  "app.post('/users', ...)",
                  "app.get('/users', ...)",
                  "app.handle('/users', ...)",
                  "app.route('/users', ...)",
                ],
                correctAnswer: 1,
                explanation:
                  "`app.get()` используется для обработки GET-запросов.",
              },
              {
                order: 4, // Общий 24
                type: "theory",
                title: "Объекты `req` и `res` в Express",
                content:
                  "Express расширяет стандартные объекты `req` и `res`:\n- `req.params`: Параметры маршрута (например, `/users/:id`).\n- `req.query`: Параметры строки запроса (после `?`).\n- `req.body`: Тело запроса (требует middleware, например `express.json()`).\n- `res.send(body)`: Отправляет ответ (может быть строка, HTML, JSON).\n- `res.json(body)`: Отправляет JSON-ответ.\n- `res.status(code)`: Устанавливает статус ответа.",
              },
              {
                order: 5, // Общий 25
                type: "theory",
                title: "Middleware (Промежуточное ПО)",
                content:
                  "Middleware — это функции, которые имеют доступ к объектам `req`, `res` и следующей функции middleware `next`. Они могут:\n- Выполнять код.\n- Изменять `req` и `res`.\n- Завершать цикл запрос-ответ.\n- Вызывать следующую middleware (`next()`).\nПримеры: `express.json()` (для парсинга JSON-тела), `express.static()` (для раздачи статических файлов).",
              },
              {
                order: 6, // Общий 26
                type: "theory",
                title: "Параметры маршрута",
                content:
                  "Можно определять динамические сегменты в пути:\n```javascript\napp.get('/users/:userId/books/:bookId', (req, res) => {\n  // req.params будет { userId: '...', bookId: '...' }\n  res.send(req.params);\n});\n```",
              },
              {
                order: 7, // Общий 27
                type: "practice_code_input",
                title: "Практика: Express API",
                content:
                  "Создайте Express-приложение, которое на GET-запрос по пути `/api/greeting` возвращает JSON `{ message: 'Hello API!' }`.",
                correctAnswer:
                  "const express = require('express');\nconst app = express();\n\napp.get('/api/greeting', (req, res) => {\n  res.json({ message: 'Hello API!' });\n});\n\napp.listen(3000);",
                explanation:
                  "Используем `app.get` для маршрута и `res.json` для отправки JSON.",
              },
            ],
          },
        ],
      },
    ],
  },
];

// Функция для инициализации базы данных
const initializeDatabase = async () => {
  const db = getFirestore();
  console.log("Попытка инициализации базы данных...");

  // --- ТЕСТ: Попытка чтения перед записью ---
  try {
    console.log("Тестовое чтение документа courses/programming-basics...");
    const testDocRef = doc(db, "courses", "programming-basics");
    const testDocSnap = await getDoc(testDocRef);
    if (testDocSnap.exists()) {
      console.log(
        "Тестовое чтение успешно, документ существует.",
        testDocSnap.data()
      );
    } else {
      console.log("Тестовое чтение успешно, документ не существует.");
    }
  } catch (readError) {
    console.error("!!! ОШИБКА при тестовом чтении:", readError);
  }

  try {
    console.log("Подготовка батча для записи...");
    const batch = writeBatch(db); // Используем батч для групповой записи

    // Добавляем каждый курс
    for (const course of coursesData) {
      const courseRef = doc(collection(db, "courses"), course.id);
      batch.set(courseRef, {
        title: course.title,
        description: course.description,
        category: course.category,
        thumbnail: course.thumbnail,
        totalLessons: course.totalLessons,
        modules: course.modules,
      });
      console.log(`Подготовлен курс: ${course.title}`);
    }

    // Записываем все изменения в базу данных
    console.log("Отправка батча в Firebase...");
    await batch.commit();
    console.log("База данных курсов успешно инициализирована!");
  } catch (error) {
    // Ловим ошибку записи
    console.error("!!! ОШИБКА при записи данных:", error); // Изменяем сообщение
    // Не выбрасываем ошибку дальше, чтобы увидеть лог чтения
    // throw error;
  }
};

// Экспортируем функцию
export default initializeDatabase;
